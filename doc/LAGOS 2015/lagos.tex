\documentclass{endm}
\usepackage{endmmacro}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{caption}
\usepackage[brazilian,english]{babel}
\usepackage[utf8]{inputenc}
%\usepackage[T1]{fontenc}
\usepackage{multirow}

% The following is enclosed to allow easy detection of differences in
% ascii coding.
% Upper-case    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
% Lower-case    a b c d e f g h i j k l m n o p q r s t u v w x y z
% Digits        0 1 2 3 4 5 6 7 8 9
% Exclamation   !           Double quote "          Hash (number) #
% Dollar        $           Percent      %          Ampersand     &
% Acute accent  '           Left paren   (          Right paren   )
% Asterisk      *           Plus         +          Comma         ,
% Minus         -           Point        .          Solidus       /
% Colon         :           Semicolon    ;          Less than     <
% Equals        =           Greater than >          Question mark ?
% At            @           Left bracket [          Backslash     \
% Right bracket ]           Circumflex   ^          Underscore    _
% Grave accent  `           Left brace   {          Vertical bar  |
% Right brace   }           Tilde        ~

\newcommand{\Nat}{{\mathbb N}}
\newcommand{\Real}{{\mathbb R}}
\def\lastname{Brito}

\begin{document}  

% DO NOT REMOVE: Creates space for Elsevier logo, ScienceDirect logo
% and ENDM logo
\begin{verbatim}\end{verbatim}\vspace{2.5cm}

\begin{frontmatter}

\title{A Computational Study of Conflict Graphs and Aggressive Cut Separation in Integer Programming}
\author{Samuel Souza Brito \and Haroldo Gambini Santos\thanksref{mailSamuelHaroldo}}
\address{{\small Dep. de Computação, Universidade Federal de Ouro Preto - UFOP}}
\author{Marcus Poggi\thanksref{mailPoggi}}
\address{{\small Dep. de Informática, Pontifícia Universidade Católica do Rio de Janeiro}}
\thanks[mailSamuelHaroldo]{Email: {\texttt{\normalshape \{samuelsouza,haroldo\}@iceb.ufop.br}}} 
\thanks[mailPoggi]{Email: {\texttt{\normalshape poggi@inf.puc-rio.br}}}  

\begin{abstract}
This work explores the fast creation of densely populated conflict graphs at the root node of the search tree for integer programs. We show that not only the Generalized Upper Bound (GUB) constraints are useful for the fast detection of cliques: these can also be quickly detected in less structured constraints in $O( n \log n )$. Routines for the aggressive separation and lifting of cliques and odd-holes are proposed. Improved bounds and a faster convergence to strong bounds were observed when comparing to the default separation routines found in the current version of the COmputation INfrastructure for Operations Research (COIN-OR) Branch and Cut solver.
\end{abstract}

\begin{keyword}
conflict graphs, integer programming, cutting planes, cliques, odd-holes
\end{keyword}

\end{frontmatter}


\section{Introduction}\label{intro}

A conflict graph (CG) represents logical relations between binary variables. CGs are typically constructed using probing techniques~\cite{Borndorfer1998} based on constraints analysis. On this work we propose an approach to speed up the creation of dense conflict graphs at the root node. Exact separation routines are employed to discover violated cliques and odd-holes, which are lifted in subsequent steps.

In Section~\ref{seccgraph} we formally explain our approach to speedup the detection of logical implications; in Section~\ref{cut} we present the cut separation and lifting routines; in Section~\ref{experiments} computational experiments are presented and finally, in Section~\ref{conclusions} we conclude and discuss the results of this work.

\section{Conflict Graphs in Integer Programming}\label{seccgraph}

A conflict graph represents logical relations between binary variables. Vertices represent variables and edges indicate that two variables cannot be set to specific values without violating one or more constraints.

Given an Integer Program (IP), a conflict graph can be constructed using probing techniques based on feasibility considerations~\cite{achterberg,atamturk}, checking the impact of fixing pairs of variables to different combinations of values. First, consider that each constraint $i \in \{1,\ldots,m\}$ can be written as $\displaystyle \sum_{j \in N} a_{ij}x_{j} \leq b_{i}$, where $N=\{1,\ldots,n\}$ is the index set of binary variables $x$, $a_{ij}$ is the coefficient for variable $x_{j}$ at constraint $i$ and $b_{i}$ is the right-hand side of constraint $i$.

Suppose we are analyzing two particular variables $x_j$ and $x_k$ with respect to constraint $i$. Consider that these variables are assigned with values $u$ and $v$, respectively. Consider also that $N_{i}^{-} = \{j \in N : a_{ij} < 0\}$. Then, $\displaystyle
L_{i}^{x_j = u,\, x_k = v}=\sum_{l\in N_{i}^{-} \setminus \{j, k\}}a_{il}+a_{ij}u+a_{ik}v $, is a lower bound for the value on the left-hand side of the constraint $i$, considering the assignments $(x_j =u,x_k=v)$. If $L_{i}^{x_j = u,\, x_k = v} > b_{i}$, a conflict is detected for these assignments. 

Performing these steps considering each pair of variables in each constraint, leads to the creation of a conflict graph in $O(m \times n^2)$, where $m$ is the number of constraints and $n$ is the number of binary variables of the problem. Nevertheless, for some constraint types a large number of conflicts can be quickly discovered such as the Generalized Upper Bound constraints ($\sum_{j\in N}x_j \leq 1$). The following paragraphs describe the developed approach, which allows to detect cliques in individual constraints faster than $O(n^2)$. Variables $\tilde{a}_{ik}$ and $\acute{a}_{ik}$ are used to indicate the $k$-th smallest coefficient in constraint $i$ and its index. Constants $n_i$ and $S_i^-$ denote the number of non-zero variables and the sum of all negative coefficients of constraint $i$.

Conflicting variables can be detected just by traversing constraints with coefficients of variables sorted in non-decreasing order. Thus, conflicts in these constraints are discovered in $O(n \log n)$. At first, consider that at a given position $k$ the summation of negative coefficients excluding the pair of variables at positions $k$ and $k+1$ in constraint $i$ is: $\displaystyle D_{i}^{x_{\acute{a}_{ik}}, x_{\acute{a}_{ik+1}}} = S_i^- - min(0, \tilde{a}_{ik}) - min(0, \tilde{a}_{ik+1})$.  Thus, the lower bound for the LHS of constraint $i$ when variables with the $k-$th and $(k+1)-$th smallest coefficients are fixed at one is: $\displaystyle LHS_{i}^{x_{\acute{a}_{ik}} = 1, x_{\acute{a}_{ik+1}} = 1} = D_{i}^{x_{\acute{a}_{ik}}, x_{\acute{a}_{ik+1}}} + \tilde{a}_{ik} + \tilde{a}_{ik+1}$.

Since $LHS_{i}^{x_{\acute{a}_{ik}} = 1, x_{\acute{a}_{ik+1}} = 1}$ is monotonically non-decreasing as $k$ increases, if $LHS_{i}^{x_{\acute{a}_{ik}} = 1, x_{\acute{a}_{ik+1}} = 1} > b_{i}$, then there is a clique involving the activation of all variables from position $k$ until position $n_i$. Moreover, we can discard the existence of such cliques by checking if $LHS_{i}^{x_{\acute{a}_{in_i-1}} = 1, x_{\acute{a}_{in_i}} = 1} \leq b_i$.

Analogously, cliques involving complementary variables from positions $n_i$ until $k$ (i.e. traversing constraint $i$ in reverse order) can be obtained or discarded by calculating the limit incurred from positions $k$ and $k-1$: $LHS_{i}^{x_{\acute{a}_{ik}} = 0, x_{\acute{a}_{ik-1}} = 0} = D_{i}^{x_{\acute{a}_{ik}}, x_{\acute{a}_{ik-1}}} $.

\begin{figure}
{\small

\begin{minipage}[b]{.5\textwidth}
 \[ \mathcal{P} = \left\{
\begin{array}{lr}
x_1+x_2+x_3 & \geq 2 \\
-2x_{1}+3x_{2}+4x_{3}+5x_{4} & \leq 4 \\
x_{1},\ldots,x_{4}\in\{0,1\}
\end{array}
\right. \]
\end{minipage}
\begin{minipage}{.5\textwidth}
	\centering
	\includegraphics[width=3.0cm]{cGraph.pdf}
\end{minipage}
}
\caption{A binary program and its conflict graph}\label{graph}
\end{figure}

As an illustrative example, Figure~\ref{graph} shows the conflict graph for a binary program $\mathcal{P}$, where $\neg x_i$ represents the complement (or deactivation) of variable $x_i$. Normal lines indicate conflicts between original variables and dashed lines indicate conflicts between complementary variables.

\section{Cutting Planes}\label{cut}

Linear programming relaxations can be significantly strengthened by the inclusion of inequalities derived from the Set Packing Polytope (SPP)~\cite{Padberg1973,Rebennack2009}. A clique inequality for a set $C$ of conflicting variables has the form $\sum_{j\in C}x_{j} \leq 1$ and an odd-hole inequality with conflicting variables $C$ can be defined as: $\sum_{j\in C}x_{j} \leq \lfloor \frac{|C|}{2}\rfloor$.

Our proposed clique separation routine has two main components: (i) a module to separate \emph{all} violated cliques in the conflict subgraph induced by variables with fractional values at linear relaxation of root node (ii) a lifting module which extends generated cliques considering the original conflict graph. The clique separation module was implemented using an improved version of the Bron-Kerbosch algorithm~\cite{Bron1973}. This version implements an optimized pivoting rule~\cite{Brito2011} to speed up the discovery of maximal cliques with large weight. The lifting module consider the original conflict graph and iteratively tries to insert inactive variables, which are previously sorted in non-decreasing order of reduced cost.

The developed odd-hole separation routine is the same used in~\cite{Rebennack2009}. The main idea is to construct an auxiliary bipartite graph from the original one and search for shortest paths with Dijkstra's algorithm to obtain odd-holes. We also lift the generated odd-holes, using similar strategy to used in the clique lifting. Iteratively, inactive variables previously sorted in non-decreasing order of reduced cost are selected and analyzed to be inserted in the generated odd-hole.

Both lifting modules are illustrated in Figure~\ref{figLiftings}. Lifted clique inequalities have the same structure: only ones in the left-hand side. A lifted odd-hole for variables $C$ and a wheel center $W$ can be written as: $\displaystyle \sum_{j \in W} \lfloor \frac{|C|}{2} \rfloor x_{j} + \sum_{j \in C} x_{j} \leq \lfloor \frac{|C|}{2} \rfloor$.

\begin{figure}	
	\begin{minipage}[h]{.5\textwidth}
		\begin{center}
			\includegraphics[width=0.5\textwidth]{clique.pdf}
		\end{center}
	\end{minipage}
	\begin{minipage}[h]{.5\textwidth}
		\begin{center}
			\includegraphics[width=0.5\textwidth]{oddHole.pdf}
		\end{center}
	\end{minipage}
	\caption{Example of a $K_{3}$ which could be lifted to a $K_{4}$ and an odd-hole and its possible extension to a wheel.} \label{figLiftings}
\end{figure}

\section{Experimental Results}\label{experiments}

Our code was written using the open source COIN-OR CLP libraries to solve linear programs and the CGL library was used to compare with our cut generation routines. All experiments ran on a computer with an Intel Core i7 3.6GHz processor and 32GB of RAM.

The first set of instances is the benchmark set of from MIPLIB 3, 2003 and 2010~\cite{miplib}. The second set of instances (INRC) comes from an IP formulation  used to solve the Nurse Rostering Problem~\cite{Santos2014} of the International Nurse Rostering Competition. Finally, the Telebus set consists in set partitioning problems from~\cite{Borndorfer1998}. Characteristics of each problem set are presented in Table~\ref{tab:inst}: columns ($n$), rows ($m$), non-zeros ($nz$). The number of edges ($|E|$) of the built graphs is also shown. ($\underline{v}$,$\overline{v}$,$\tilde{v}$) indicates minimum, maximum and average values. Finally, the last two columns presents the total time (in seconds) spent in the construction of conflict graphs for all instances of each set, using pairwise detection ($PD$) and our algorithm ($FCG$).

\begin{table}[h]
\scriptsize
\caption{Characteristics of instance sets and their conflict graphs.}\label{tab:inst}
\begin{center}
\begin{tabular}{|l|c|c|c|c|r|r|}
\hline 
\multirow{2}{0.8cm}{Inst. Set} & \multicolumn{3}{c|}{{Problem Sizes ($\times10^{3}$)}} & {CG ($\times10^{6}$)} & \multicolumn{2}{c|}{{Time (s)}}\tabularnewline
\cline{2-7} 
 & {$\underline{n}$/$\overline{n}$/$\tilde{n}$} & {$\underline{m}$/$\overline{m}$/$\tilde{m}$} & {$\underline{nz}$/$\overline{nz}$/$\tilde{nz}$} & {$|\underline{E}|$/$|\overline{E}|$/$\tilde{|E|}$} & \multicolumn{1}{c|}{PD} & \multicolumn{1}{c|}{FCG}\tabularnewline
\hline 
\hline 
\texttt{MIPLIB} & {0.1/164.6/13.7} & {0.1/624.2/32.1} & {0.7/27678.7/515.9} & {0/11.4/0.4} & {198.8} & {17.5}\tabularnewline
\hline 
\texttt{INRC} & {9.8/63.6/29.7} & {3/29.2/11.7} & {201.1/1068.1/534.8} & {2.5/12.8/6.5} & {713.0} & {496.3}\tabularnewline
\hline 
\texttt{Telebus} & {1.1/146.7/33.7} & {0.3/1.8/1} & {1.4/545.3/135.6} & {0.1/1935.5/80} & {14734.6} & {540.2}\tabularnewline
\hline 
\end{tabular}
\end{center}
\end{table}

Figure~\ref{figExperiments} shows the average gap closed improvement for each instance set where COIN-OR CGL (CGL) and our separation routines with (LNPSEP) and without lifting module (NPSEP) are compared. We removed infeasible instances and instances where neither our code or CGL found violated inequalities, remaining 21 instances of MIPLIB, 40 of INRC and 14 of Telebus set. The time limit was fixed in 300 seconds. While remarkable improvements were obtained in the INRC instances (from 57.67 with CGL to 77.47 with LNPSEP), which have a large number of dense set partitioning and packing constraints, a modest improvement occurred in MIPLIB instances. The average lower bound for this instances was improved from 51.06, obtained with CGL, to 53.39, obtained with LNPSEP within the time limit imposed. We did not included the Telebus results because all strategies performed equally well on these instances.

\begin{figure}	
	\begin{minipage}[h]{.5\textwidth}
		\begin{center}
			\includegraphics[width=1\textwidth]{miplib.eps}
		\end{center}
	\end{minipage}
	\begin{minipage}[h]{.5\textwidth}
		\begin{center}
			\includegraphics[width=1\textwidth]{nurse.eps}
		\end{center}
	\end{minipage}
	\caption{Dual bound improvement using LNPSEP, NPSEP and CGL routines.}
	\label{figExperiments}
\end{figure}

\section{Conclusions}\label{conclusions}

We developed an approach for fast creation of densely CGs using the detection of cliques in less structured constraints. A speedup of up to 30 times was obtained in the overall time to create an initial conflict graph. We also proposed and implemented a cut separation procedure. Experiments show that our cut generator can produce significantly better dual bounds than COIN-OR CGL, specially in restricted execution times.

\bibliographystyle{endm}
\bibliography{references}

\end{document}
