%% 
%% Copyright 2007, 2008, 2009 Elsevier Ltd
%% 
%% This file is part of the 'Elsarticle Bundle'.
%% ---------------------------------------------
%% 
%% It may be distributed under the conditions of the LaTeX Project Public
%% License, either version 1.2 of this license or (at your option) any
%% later version.  The latest version of this license is in
%%    http://www.latex-project.org/lppl.txt
%% and version 1.2 or later is part of all distributions of LaTeX
%% version 1999/12/01 or later.
%% 
%% The list of all files belonging to the 'Elsarticle Bundle' is
%% given in the file `manifest.txt'.
%% 

%% Template article for Elsevier's document class `elsarticle'
%% with numbered style bibliographic references
%% SP 2008/03/01

\documentclass[preprint,12pt]{elsarticle}

%% Use the option review to obtain double line spacing
%% \documentclass[authoryear,preprint,review,12pt]{elsarticle}

%% Use the options 1p,twocolumn; 3p; 3p,twocolumn; 5p; or 5p,twocolumn
%% for a journal layout:
%% \documentclass[final,1p,times]{elsarticle}
%% \documentclass[final,1p,times,twocolumn]{elsarticle}
%% \documentclass[final,3p,times]{elsarticle}
%% \documentclass[final,3p,times,twocolumn]{elsarticle}
%% \documentclass[final,5p,times]{elsarticle}
%% \documentclass[final,5p,times,twocolumn]{elsarticle}

%% For including figures, graphicx.sty has been loaded in
%% elsarticle.cls. If you prefer to use the old commands
%% please give \usepackage{epsfig}

%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
%% The amsthm package provides extended theorem environments
%% \usepackage{amsthm}

%% The lineno packages adds line numbers. Start line numbering with
%% \begin{linenumbers}, end it with \end{linenumbers}. Or switch it on
%% for the whole article with \linenumbers.
%% \usepackage{lineno}

\usepackage{amsmath}
\usepackage[utf8]{inputenc}

\journal{Discrete Applied Mathematics}

\begin{document}

\begin{frontmatter}

%% Title, authors and addresses

%% use the tnoteref command within \title for footnotes;
%% use the tnotetext command for theassociated footnote;
%% use the fnref command within \author or \address for footnotes;
%% use the fntext command for theassociated footnote;
%% use the corref command within \author for corresponding author footnotes;
%% use the cortext command for theassociated footnote;
%% use the ead command for the email address,
%% and the form \ead[url] for the home page:
%% \title{Title\tnoteref{label1}}
%% \tnotetext[label1]{}
%% \author{Name\corref{cor1}\fnref{label2}}
%% \ead{email address}
%% \ead[url]{home page}
%% \fntext[label2]{}
%% \cortext[cor1]{}
%% \address{Address\fnref{label3}}
%% \fntext[label3]{}

\title{Using Conflict Graphs to Obtain Strong Dual Bounds in Integer Programming Problems}

%% use optional labels to link authors explicitly to addresses:
%% \author[label1,label2]{}
%% \address[label1]{}
%% \address[label2]{}

\author[samuel]{Samuel Souza Brito\corref{cor1}}
\cortext[cor1]{Corresponding author.}
\ead{samuelbrito@decsi.ufop.br}
\address[samuel]{Departamento de Computação e Sistemas de Informação, Universidade Federal de Ouro Preto, Brazil}

\author[haroldo]{Haroldo Gambini Santos}
\ead{haroldo@iceb.ufop.br}
\address[haroldo]{Departamento de Computação, Universidade Federal de Ouro Preto, Brazil}

\begin{abstract}
This work explores the structural information of relations between binary variables in Integer Programming problems using conflict graphs. We present some improvements in the process of conflict detection which allow the fast construction of dense graphs. Furthermore, we develop routines to generate clique and odd hole cuts based on the analysis of conflict graphs. The results obtained by the cut generation routines showed a faster convergence to the optimal solution when compared with the cut separation routine of COIN-OR Branch-and-Cut solver.
\end{abstract}

\begin{keyword}
%% keywords here, in the form: keyword \sep keyword
Conflict Graphs \sep Integer Programming \sep Cutting Planes \sep Cliques \sep Odd Holes.

%% PACS codes here, in the form: \PACS code \sep code

%% MSC codes here, in the form: \MSC code \sep code
%% or \MSC[2008] code \sep code (2000 is the default)

\end{keyword}

\end{frontmatter}

%% \linenumbers

%% main text
\section{Introduction}

In this work we present an approach to build conflict graphs for Integer Programming (IP) problems. A Conflict Graph represents logical relations between binary variables. This kind of graph has a vertex for each binary variable and its complement. An edge between two vertices indicates that variables (or complement of variables) involved cannot be equal one without violating some constraints.

Conflict graphs are typically constructed using probing techniques~\cite{Borndorfer1998} based on constraints analysis. The probing technique consists in analyzing logical implications generated by the fixing of pairs of binary variables. For example, in a given problem the assignment of value one to the variable $x$ could imply the assignment of value zero to the variable $y$, in order to respect the constraints of the problem. In this case, we found the implication ``if $x = 1$, then $y = 0$'', which induces an edge between $x$ and $y$ in the graph.

One important application for conflict graphs is the generation of cutting planes derived from the Set Packing Polytope~\cite{Padberg1973}, such as the Clique Inequalities. The dynamic inclusion of these inequalities allows tightening the linear relaxation of an IP problem, improving performance of branch-and-bound based solvers~\cite{atamturk}. Hoffman and Padberg~\cite{hoffman} used conflict graphs to generate valid inequalities for set partitioning problems arising in airline crew-scheduling. Achterberg~\cite{achterberg} presented heuristics based on SAT techniques for Mixed Integer Programming solvers to generate valid inequalities from the current infeasible subproblem and the associated branching information. The same idea has been developed independently and in parallel by Sandholm and Shields~\cite{sandholm}.  

On this work we propose and implement an approach to speed up the creation of dense conflict graphs. Furthermore, we use these graphs to generate clique and odd hole cuts and insert them at the root node of the linear relaxation, obtaining strong dual bounds.

The rest of the paper is organized as follows. In Section \ref{cgraph}, we formally explain the basic approach to build conflict graphs as well our strategy to speedup the detection of logical implications. In Section \ref{preprocessing}, we explain some preprocessing techniques used before the cut generation step. In Section \ref{cuts}, we present our clique and odd hole cut separation routines. In Section \ref{experiments}, the computational experiments with MIPLIB 2010 instances \cite{miplib} and instances of the International Nurse Rostering Competition \cite{haspeslagh} are presented and analyzed. Finally, in Section \ref{conclusions}, we conclude and give future directions about this work.

\section{Conflict Graphs for Integer Programming Problems}\label{cgraph}

A conflict graph represents logical relations between binary variables. For two binary variables $x$ and $y$, there are four possible logical relations:

\begin{align}
x = 1 \implies y = 0 & \therefore \text{conflict between } x \text{ and } y\nonumber\\
x = 1 \implies y = 1 & \therefore \text{conflict between } x \text{ and } \bar{y}\nonumber\\
x = 0 \implies y = 0 & \therefore \text{conflict between } \bar{x} \text{ and } y\nonumber\\
x = 0 \implies y = 1 & \therefore \text{conflict between } \bar{x} \text{ and } \bar{y}\nonumber
\end{align}

\noindent where notation $\bar{x}$ represents the complement of binary variable $x$ (i.e. it represents $1 - x$).

Given an Integer Programming (IP) problem, a conflict graph can be constructed using probing techniques based on feasibility considerations, checking the impact of fixing pairs of binary variables to different combinations of values. For ease of presentation and understanding, the remainder of this section considers only pure 0-1 IP problems. Despite this, all mechanisms presented can be applied to any IP problem containing binary variables.

First, consider that each constraint $i \in \{1,\ldots,m\}$, with $m$ being the number of constraints of the input problem, can be written as one or two equations of the form:

\begin{equation}
 \sum_{j \in N} a_{ij}x_{j} \leq b_i
\end{equation}

\noindent where $N$ is the index set of binary variables $x$, $a_{ij}$ is the coefficient of variable $x_{j}$ in the constraint $i$ and $b_i$ is the right-hand side of the constraint $i$.

Suppose we are analyzing two particular binary variables $x_j$ and $x_k$ with respect to the constraint $i$. Consider that these variables are assigned with values $u$ and $v$, respectively. Let:

\begin{equation}\label{li}
L_{i}^{x_j = u,\, x_k = v}=\sum_{l\in N_{i}^{-} \setminus \{j, k\}}a_{il}+a_{ij}u+a_{ik}v 
\end{equation}

\noindent where $N_{i}^{-} = \{j \in N : a_{ij} < 0\}$. In this case, $L_{i}^{x_j = u,\, x_k = v}$ is a lower bound for the value on the left-hand side  of the constraint $i$, considering the assignments $x_j = u$ and $x_k = v$. If $L_{i}^{x_j = u,\, x_k = v} > b_{i}$, there is a conflict between the assignments of $x_j$ and $x_k$. 

By performing this calculation for each combination of values of two binary variables, considering each pair of variables in each constraint, we obtain a conflict graph for any IP problem. Thus, a conflict graph can be constructed in $O(m \times n^2)$ steps, where $m$ is the number of constraints and $n$ is the number of variables of the problem. However, for IP problems with a large set of variables and constraints this technique may be expensive computationally. In this sense, the following subsection describes an approach to detect conflicts faster than $O(m \times n^2)$ steps, allowing the fast construction of dense conflict graphs.

\subsection{Fast Detection of Conflicts}
























\section{Preprocessing Step}\label{preprocessing}

Preprocessing tries to improve the representation of MIP problems. Thus, problems are reformulated in order to reduce their size and decrease the difference in the objective function values between the solutions to the linear programming relaxation and the integer program.

We run a preprocessing step before performing the cut separation routine. This step uses basic preprocessing and basic probing techniques proposed by Savelsbergh~\cite{Savelsbergh1994}. We also use constraint propagation technique to fix binary variables. The next subsections will explain all preprocessing techniques used on this work.

\subsection{Basic Preprocessing and Basic Probing Techniques}

For understanding the basic preprocessing and probing techniques consider the following notation:

\begin{itemize}
\item \textbf{$x_j$}: binary decision variable with index $j$;
\item \textbf{$y_j$}: integer or continuous decision variable with index $j$;
\item \textbf{$a_{ij}$}: coefficient for variable $x_{j}$ in constraint $i$;
\item \textbf{$g_{ij}$}: coefficient for variable $y_{j}$ in constraint $i$;
\item \textbf{$B_i^+$}: index set of binary variables with positive coefficients in $i$;
\item \textbf{$B_i^-$}: index set of binary variables with negative coefficients in $i$;
\item \textbf{$C_i^+$}: index set of integer or continuous variables with positive coefficients in $i$;
\item \textbf{$C_i^-$}: index set of integer or continuous variables with negative coefficients in $i$;
\item \textbf{$l_{x_j}$}: lower bound of binary variable $x_j$ (used to avoid wrong calculations involving fixed variables);
\item \textbf{$u_{x_j}$}: upper bound of binary variable $x_j$ (used to avoid wrong calculations involving fixed variables);
\item \textbf{$l_{y_j}$}: lower bound of integer or continuous variable $y_j$;
\item \textbf{$u_{y_j}$}: upper bound of integer or continuous variable $y_j$;
\item \textbf{$b_i$}: right-hand side of constraint $i$.

\end{itemize}

\subsubsection{Identification of infeasibility}

\begin{align}
	z = \sum_{j \in B_i^+}{a_{ij}l_{x_j}} + \sum_{j \in B_i^-}{a_{ij}u_{x_j}} + \sum_{j \in C_i^+}{g_{ij}l_{y_j}} + \sum_{j \in C_i^-}{g_{ij}u_{y_j}}
\end{align}

If $z > b_{i}$, then the problem is infeasible.

\subsubsection{Identification of redundancy}

\begin{align}
	z = \sum_{j \in B_i^+}{a_{ij}u_{x_j}} + \sum_{j \in B_i^-}{a_{ij}l_{x_j}} + \sum_{j \in C_i^+}{g_{ij}u_{y_j}} + \sum_{j \in C_i^-}{g_{ij}l_{y_j}}
\end{align}

If $z \leq b_{i}$, then the constraint $i$ is redundant.

\subsubsection{Improving bounds}

Considering a variable $y_k$, $k \in C_i^{+}$:

\begin{align}
	z_k = \sum_{j \in B_i^+}{a_{ij}l_{x_j}} + \sum_{j \in B_i^-}{a_{ij}u_{x_j}} + \sum_{j \in C_i^+ \setminus\{k\}}{g_{ij}l_{y_j}} + \sum_{j \in C_i^-}{g_{ij}u_{y_j}}
\end{align}

If $\frac{b_i - z_k}{g_ik} < u_k$, the upper bound $u_{y_k}$ can be improved.

Considering a variable $y_k$, $k \in C_i^{-}$:

\begin{align}
	z_k = \sum_{j \in B_i^+}{a_{ij}l_{x_j}} + \sum_{j \in B_i^-}{a_{ij}u_{x_j}} + \sum_{j \in C_i^+}{g_{ij}l_{y_j}} + \sum_{j \in C_i^-\setminus\{k\}}{g_{ij}u_{y_j}}
\end{align}

If $\frac{z_k - b_i}{-g_ik} > l_k$, the lower bound $l_{y_k}$ can be improved.

\subsubsection{Fixing variables}

Considering a variable $x_k$, $k \in B_i^{+}$:

\begin{align}
	z_k = a_{ik}u_{x_k} + \sum_{j \in B_i^+\setminus\{k\}}{a_{ij}l_{x_j}} + \sum_{j \in B_i^-}{a_{ij}u_{x_j}} + \sum_{j \in C_i^+}{g_{ij}l_{y_j}} + \sum_{j \in C_i^-}{g_{ij}u_{y_j}}
\end{align}

If $z_k > b_i$, then $x_k$ can be fixed to 0.

Considering a variable $x_k$, $k \in B_i^{-}$:

\begin{align}
	z_k = \sum_{j \in B_i^+}{a_{ij}l_{x_j}} + a_{ik}l_{x_k} + \sum_{j \in B_i^-\setminus\{k\}}{a_{ij}u_{x_j}} + \sum_{j \in C_i^+}{g_{ij}l_{y_j}} + \sum_{j \in C_i^-}{g_{ij}u_{y_j}}
\end{align}

If $z_k > b_i$, then $x_k$ can be fixed to 1.

\subsubsection{Improving coefficients}

Considering a variable $x_k$, $k \in B_i^{+}$:

\begin{align}
	z_k = a_{ik}l_k + \sum_{j \in B_i^+\setminus\{k\}}{a_{ij}u_{x_j}} + \sum_{j \in B_i^-}{a_{ij}l_{x_j}} + \sum_{j \in C_i^+}{g_{ij}u_{y_j}} + \sum_{j \in C_i^-}{g_{ij}l_{y_j}}
\end{align}

If $z_k < b_i$, then $a_{ik}$ and $b_i$ can be decreased by $\delta = b_i - z_k$ ($a_{ik} = a_{ik} - \delta$ and $b_i = b_i - delta$).

Considering a variable $x_k$, $k \in B_i^{-}$:

\begin{align}
	z_k = \sum_{j \in B_i^+}{a_{ij}u_{x_j}} + a_{ik}u_k + \sum_{j \in B_i^-\setminus\{k\}}{a_{ij}l_{x_j}} + \sum_{j \in C_i^+}{g_{ij}u_{y_j}} + \sum_{j \in C_i^-}{g_{ij}l_{y_j}}
\end{align}

If $z_k < b_i$, then $a_{ik}$ can be increased by $\delta = b_i - z_k$ ($a_{ik} = a_{ik} + \delta$).

\section{Aggressive Cut Separation}\label{cuts}

\section{Experimental Results}\label{experiments}

\section{Conclusions}\label{conclusions}

%% The Appendices part is started with the command \appendix;
%% appendix sections are then done as normal sections
%% \appendix

%% \section{}
%% \label{}

%% If you have bibdatabase file and want bibtex to generate the
%% bibitems, please use
%%
\section*{References}
  \bibliographystyle{elsarticle-num} 
  \bibliography{references}

%% else use the following coding to input the bibitems directly in the
%% TeX file.

%\begin{thebibliography}{00}

%% \bibitem{label}
%% Text of bibliographic item

%\bibitem{}

%\end{thebibliography}
\end{document}
\endinput
%%
%% End of file `elsarticle-template-num.tex'.
